---
title: 并发编程（三）：并行程序基础
date: 2018-06-02 21:35:05
tags: ["多线程"]
categories: ["多线程"]

---

线程状态
线程终止
线程中断
线程等待和通知
挂起和继续执行
等待线程结束和谦让
volatile 和 java 内存模型
线程组
线程的优先级
守护线程
线程安全概念和 synchronized

<!--more-->

#### 线程状态

线程可以有以下 6 种状态
&emsp;&emsp;New 新创建 线程还没有开始运行
&emsp;&emsp;Runnable 可运行 调用 start 方法，线程处于 Runnable 状态
&emsp;&emsp;Blocked 被阻塞 当一个线程试图获取一个内部的对象锁，而该所被其他对象所持有，则该线程进入阻塞状态，当其他所有线程释放该锁，并且线程调度器允许本线程持有它的时候，则该线程变成非阻塞状态
&emsp;&emsp;Waiting 等待 当线程等待两一个线程通知调度器一个条件时，它自己进入等待状态。在调用 object.wait 方法或 thread.join 方法或者是等待 java.util.concurrent 库中的 Lock 或 Condition 时，就会出现这种情况，实际上被阻塞状态与当代状态是有很大不同的。
&emsp;&emsp;Timed Waiting 计时等待，有几个方法带有超时参数，调用它们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接受到适当的通知，被调用 notify 或 notifyAll 方法。带有超时参数的方法有 Thread.sleep,Object.wait、Thread.join、Thread.join、Lock.tryLock、Condition.await 的计时版
&emsp;&emsp;Terminated 被终止 因 run 方法正常退出而终止,因为没有捕获的异常而意外终止

#### 线程终止

调用 stop()方法线程终止,stop()方法被废弃

#### 线程中断

&emsp;&emsp;线程中断不会是线程立即退出，而是给线程发送一个通知，告知目标线程，退出。如果，中断后，线程立即无条件退出，我们又会遇到 stop()方法的老问题。与线程中断有关的，有三个方法，这三个方法看起来很像，所以可能会引起混淆和误用。
Thread.interrupt() 中断线程
Thread.isInterrupted() 判断是否被中断
Thread.interrupted() 判断是否被中断，并清除当前的中断状态

#### 线程等待和通知

&emsp;&emsp;wait() 方法，当前线程等待，直到被调用 notify 或 notifyAll 方法重新执行
&emsp;&emsp;wait() notify() notifyAll() 为 Object 方法，使用时，需在当前对象上加锁

#### 挂起和继续执行

&emsp;&emsp;suspend()线程挂起和 resume()继续执行，是被标注为废弃的方法，并不推荐使用。suspend()方法，不推荐使用的原因是：在导致线程暂停的同时，并不会去释放任何锁资源。此时，其他任何线程想要访问被他暂用的锁时，都会被牵连，导致无法正常继续运行。直到对应的线程上进行了 resume()操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是 ，如果 resume()操作以外的在 suspend()前就执行了，那么被挂起的线程可能很难有机会被继续执行。并且，更严重的是：他所占用的锁不会被释放，因此可能会导致整个系统工作不正常，而且，对于被挂起的线程，从它的线程状态上看，居然还是 Runnable,这也会严重影响我们对系统当前状态的判断。

#### 等待线程结束和谦让

- thread.join()
  一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖线程执行完毕，才能继续执行。JDK 提供了 join()操作来实现这个功能
- thread.yield()
  这是一个静态方法，一旦执行，会使当前线程让出 CPU,但是当前线程可能会继续参与资源的争夺。

#### volatile 和 java 内存模型

&emsp;&emsp;volatile 对于保证操作的原子性是有非常大的帮助的。但是需要注意的是，volatile 并不能代替锁，他也无法保证一些复合操作的原子性。比如狭隘难得例子，通过 volatile 是无法保证 i++的原子性操作的。
&emsp;&emsp;此外,volatile 也能保证数据的可见性和有序性。

#### 线程组

&emsp;&emsp;在一个系统中，如果线程的数量很多，而且功能分配比较明确，就可以将相同功能的线程放置在一个线程组里。

#### 线程的优先级

&emsp;&emsp;优先级高的线程在竞争资源时会更有优势，更可能抢占资源，但不代表一定能抢占到资源。同样低优先级的线程不代表一定抢占不到资源。如果低优先记得线程始终抢占不到线程，始终无法运行，则产生饥饿。因此，在要求严格的场合还是需要在应用层解决线程调度问题。

#### 守护线程

&emsp;&emsp;调用 setDaemon(true)将线程转换为守护线程，守护线程的作用是为其他线程提供服务。当 Java 应用内只有守护线程时，Java 虚拟机就会自然退出。

#### 线程安全概念和 synchronized

&emsp;&emsp;当两个线程同时修改某一个数据的时候，产生冲突导致线程不安全。volatile 并不能保证线程安全。
&emsp;&emsp;关键字 synchronized 作用是实现线程间的同步，他的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程间的安全性
关键字 synchronized 的用法：

- 指定加锁的对象: 对给定的对象加锁，进入同步代码前要获得给定对象的锁
- 直接作用于实例方法： 相当于对当前实例加锁，计入同步代码前要获得当前实例的锁
- 直接作用于静态方法： 相当于对当前类加锁，进入同步代码前要获得当前类的锁

&emsp;&emsp;除了用于线程同步、确保线程安全，sychronized 还可以保证线程间的可见性和有序性，从可见性的角度上讲，synchronized 可以完全替代 volatile 的功能，只是使用上没有那么方便 。就有序性而言，由于 synchronized 限制每次只有一个线程可以访问同步块，因此无论同步块内的代码如何被乱序执行，只要保证串行语义一致，那么执行结果总是一样的。而其他访问线程，又必须在获得锁后，方能计入代码块读取数据，因此，它们看到的最终结果并不取决于代码的执行过程，从而有序性问题自然得到了解决。
