---
title: 并发编程（一）：前言
date: 2018-01-31 22:43:48
tags: ["多线程"]
categories: ["多线程"]

---

### 一.并行演变：

&emsp;&emsp;一开始是单核，然后有一屌人，戈登.摩尔英特尔创始人提出了摩尔定律，大概的意思就是每到 18 个月到 24 个月，我们的计算机性能就能翻一番。摩尔定律的有效性已经超过半个世纪了，然而，在 2004 年秋季，intel 宣布取消 4GHz 计划，因此，摩尔定律在 CPU 的计算性能上可能已经失效，在近 10 年的发展中，cpu 主频的提升明显遇到了一些暂时不能逾越的瓶颈。2005 年开始，从单核到多核，然后软件上就是从串行程序到并行程序。

<!--more-->

- 同步：是所有的操作都做完，才返回给用户结果。即写完数据库之后，在相应用户，用户体验不好。
- 异步：不用等所有操作等做完，就相应用户请求。即先相应用户请求，然后慢慢去写数据库，用户体验较好。

### 二.需要了解的一些概念：

#### 1.并发跟并行

- **并发**：并发偏重于多个任务交替进行，而多个任务之间有可能还是串行的。
- **并行**：是真正意义上的同时执行，

#### 2.临界区：

&emsp;&emsp;临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用，其他线程想要使用就必须等待。

#### 3.阻塞(blocking)和非阻塞(non-blocking)

- **阻塞**：比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程的挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。
- **非阻塞**的意思与之相反

#### 4.死锁(deadlock)、饥饿(starvation)、活锁(livelock)

- **饥饿**：线程因为种种原因无法获取到他需要的资源，导致一直无法执行，比如它的线程优先级可能太低
- **活锁**：主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行，这种情况就是活锁。
- **死锁**：线程占用资源，无法释放，类似于陷入死循环

#### 5.并发级别：

- **阻塞**：如果当前线程得不到资源，线程就会被挂起等待，直到占有了所需的资源位置

- **无饥饿**：线程之间有优先级，那么线程调度的时候总是会倾向于满足高优先级的线程。对于非公平的锁来说，系统语序高优先级的线程插队，这样有可能导致优先级线程产生饥饿，单如果锁是公平的，满足先来后到，那么饥饿就不会产生。不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。

- **无障碍**：无障碍是一种最弱的非阻塞调度，自由出入临界区，无竞争时，有限不内完成操作，有竞争时，回滚数据

- **无锁**： 是无障碍的，保证有一个线程可以胜出
- **无等待**: 无锁的，要求所有的线程都必须在有限步内完成，无饥饿的。

### 三、有关并行的两个重要定律：

1. **Amdahl 阿姆达尔定律 加速比：**优化系统耗时/优化后系统耗时
2. **Gustafson 古斯塔夫森定律：** 说明处理器个数，串行比例和加速比之间的关系，只要有足够的并行化，那么加速比和 CPU 个数成正比
